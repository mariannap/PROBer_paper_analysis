import re

# Shared

def get_ref(wildcards):
	ref_name = ""
	name = wildcards.sample if hasattr(wildcards, "sample") else wildcards.experiment

	if name.startswith("structure_seq_spike"):
		ref_name = arabidopsis_spike
	elif name.startswith("structure_seq"):
		ref_name = arabidopsis_filt
	elif name.startswith("mod_seq") or name.startswith("pseudo_seq"):
		ref_name = yeast_filt
	elif name.startswith("icSHAPE"):
		ref_name = mouse_filt
	elif name.startswith("ChemModSeq"):
		ref_name = yeast_rRNAs
	else:
		assert False

	return ref_name

def get_data_as_input(wildcards):
	if re.search("(sim|spike)", wildcards.sample):
		return ["{path}/{sample}.fq".format(path = sim_path, sample = wildcards.sample)]
	return sample_name_to_data[wildcards.sample]

def get_data_as_param(wildcards):
	return ",".join(get_data_as_input(wildcards))

def get_bowtie_params(wildcards):
	if wildcards.sample.startswith("structure_seq"):
		return "-v 3"
	return "--chunkmbs 500"


rule bowtie_alignment_all:
	input: get_ref, get_data_as_input, Bowtie, Samtools
	params: bowtie = get_bowtie_params, data = get_data_as_param
	output:
		"{path}/{{sample,(structure_seq|mod_seq|pseudo_seq|icSHAPE)\w+}}_all.bam".format(path = exp_path)
	log:
		"{path}/{{sample}}_all.log".format(path = exp_path)
	threads: 20
	shell:
		"{Bowtie} --norc {params.bowtie} -a -m 200 -p {threads} -S {input[0]} {params.data} 2> {log} | {Samtools} view -S -b -o {output} -"

rule bowtie_alignment_best_strata:
	input: get_ref, get_data_as_input, Bowtie, Samtools
	params: bowtie = get_bowtie_params, data = get_data_as_param
	output:
		"{path}/{{sample,(structure_seq|mod_seq|pseudo_seq|icSHAPE)\w+}}_best_strata.bam".format(path = exp_path)
	log:
		"{path}/{{sample}}_best_strata.log".format(path = exp_path)
	threads: 20
	shell:
		"{Bowtie} --norc {params.bowtie} -a --best --strata -p {threads} -S {input[0]} {params.data} 2> {log} | {Samtools} view -S -b -o {output} -"

rule bowtie_alignment_best:
	input: get_ref, get_data_as_input, Bowtie, Samtools
	params: bowtie = get_bowtie_params, data = get_data_as_param
	output:
		"{path}/{{sample,(structure_seq|mod_seq|pseudo_seq|icSHAPE)\w+}}_best.bam".format(path = exp_path)
	log:
		"{path}/{{sample}}_best.log".format(path = exp_path)
	threads: 20
	shell:
		"{Bowtie} --norc {params.bowtie} --best -p {threads} -S {input[0]} {params.data} 2> {log} | {Samtools} view -S -b -o {output} -"


def get_mate1(wildcards):
	if wildcards.sample == "ChemModSeq_minus":
		return ",".join(["{path}/{run}_cleaned_1.fq".format(path = GrannemanLab, run = run) for run in ["SRR1041324", "SRR1041325", "SRR1041326"]])
	else:
		return ",".join(["{path}/{run}_cleaned_1.fq".format(path = GrannemanLab, run = run) for run in ["SRR1041327", "SRR1041328", "SRR1041329"]])

def get_mate2(wildcards):
	if wildcards.sample == "ChemModSeq_minus":
		return ",".join(["{path}/{run}_cleaned_2.fq".format(path = GrannemanLab, run = run) for run in ["SRR1041324", "SRR1041325", "SRR1041326"]])
	else:
		return ",".join(["{path}/{run}_cleaned_2.fq".format(path = GrannemanLab, run = run) for run in ["SRR1041327", "SRR1041328", "SRR1041329"]])

rule bowtie2_alignment_all:
	input: get_ref, get_data_as_input, Bowtie2, Samtools
	params: mate1 = get_mate1, mate2 = get_mate2
	output:
		"{path}/{{sample,ChemModSeq\w+}}_all.bam".format(path = exp_path)
	log:
		"{path}/{{sample}}_all.log".format(path = exp_path)
	threads: 20
	shell:
		"bowtie2 --norc -a -p {threads} -I 1 -X 700 --no-mixed --no-discordant -x {input[0]} -1 {params.mate1} -2 {params.mate2} 2> {log} | {Samtools} view -S -b -o {output} -"

rule bowtie2_alignment_best_strata:
	input: get_ref, get_data_as_input, Bowtie2, Samtools
	params: mate1 = get_mate1, mate2 = get_mate2
	output:
		"{path}/{{sample,ChemModSeq\w+}}_best_strata.bam".format(path = exp_path)
	log:
		"{path}/{{sample}}_best_strata.log".format(path = exp_path)
	threads: 20
	shell:
		"bowtie2 --norc -p {threads} -I 1 -X 700 --no-mixed --no-discordant -x {input[0]} -1 {params.mate1} -2 {params.mate2} 2> {log} | {Samtools} view -S -b -o {output} -"

rule bowtie2_alignment_best:
	input: get_ref, get_data_as_input, Bowtie2, Samtools
	params: mate1 = get_mate1, mate2 = get_mate2
	output:
		"{path}/{{sample,ChemModSeq\w+}}_best.bam".format(path = exp_path)
	log:
		"{path}/{{sample}}_best.log".format(path = exp_path)
	threads: 20
	shell:
		"bowtie2 --norc -k 1 -p {threads} -I 1 -X 700 --no-mixed --no-discordant -x {input[0]} -1 {params.mate1} -2 {params.mate2} 2> {log} | {Samtools} view -S -b -o {output} -"


ruleorder: sort_bam_by_name > bowtie_alignment_all


def get_PROBer_params(wildcards):
	params = ""
	if wildcards.experiment.startswith("structure_seq"):
		params = "--size-selection-min 21 --size-selection-max 526 --read-length 37"
	elif wildcards.experiment.startswith("mod_seq"):
		params = "--primer-length 0 --size-selection-min 23 --size-selection-max 220 --read-length 50"
	elif wildcards.experiment.startswith("pseudo_seq"):
		params = "--primer-length 0 --size-selection-min 18 --size-selection-max 130 --read-length 41"
	elif wildcards.experiment.startswith("ChemModSeq"):
		params = "--paired-end --size-selection-min 18 --size-selection-max 700"
	else:
		assert False

	return params


rule run_PROBer:
	input:
		get_ref,
		expand("{path}/{{experiment}}_{channel}_all.bam", path = exp_path, channel = ["plus", "minus"]),
		PROBer
	params: get_PROBer_params
	output:
		expand("{path}/{{experiment}}_PROBer.{suffix}", path = exp_path, suffix = ["beta", "gamma", "expr"]),
		expand("{path}/{{experiment}}_PROBer.stat/{{experiment}}_PROBer_{channel}.{suffix}",
			path = exp_path, channel = ["minus", "plus"], suffix = ["read_model", "theta"])
	threads: 20
	shell:
		"{PROBer} estimate -p {threads} {params} {input[0]} {exp_path}/{wildcards.experiment}_PROBer --alignments {input[1]} {input[2]}"

rule run_PROBer_icSHAPE:
	input:
		mouse_filt,
		expand("{path}/icSHAPE_{{condition}}_all.bam", path = exp_path),
		PROBer
	params:
		"{path}/icSHAPE_{{condition}}_PROBer".format(path = exp_path)
	output:
		expand("{path}/icSHAPE_{{condition}}_PROBer.{suffix}", path = exp_path, suffix = ["beta", "expr"])
	threads: 20
	shell:
		"{PROBer} estimate -p {threads} --primer-length 0 --size-selection-min 20 --size-selection-max 120 --read-length 87 {input[0]} {params} --alignments {input[1]}"

ruleorder: run_PROBer_icSHAPE > run_PROBer


def get_score_input(wildcards):
	name = wildcards.experiment
	channels = ["minus", "plus"]
	if name == "icSHAPE_invitro":
		name = "icSHAPE"
		channels = ["dmso", "invitro"]
	elif name == "icSHAPE_invivo":
		name = "icSHAPE"
		channels = ["dmso", "invivo"]

	input_list = expand("{path}/{name}_{channel}_{method}.counts", 
						path = exp_path, name = name, channel = channels, method = wildcards.method)

	return input_list


rule extract_count_vector_StructureFold_or_Pseudoseq:
	input:
		"{path}/{{sample}}_best_strata.bam".format(path = exp_path)
	output:
		"{path}/{{sample}}_{{method,(StructureFold|Pseudoseq)}}.counts".format(path = exp_path)
	shell:
		"{script_path}/extractCountVectors {input} {output} 1 all"

rule calculate_StructureFold_score:
	input: get_score_input
	output:
		"{path}/{{experiment}}_{{method,StructureFold}}.scores".format(path = exp_path)
	shell:
		"{script_path}/calcStructureFold {input} {output}"

rule extract_count_vector_Modseeker:
	input:
		"{path}/{{sample}}_best.bam".format(path = exp_path)
	output:
		"{path}/{{sample}}_Modseeker.counts".format(path = exp_path)
	shell:
		"{script_path}/extractCountVectors {input} {output} 0 all"

rule calculate_Modseq_score:
	input: get_score_input
	output:
		"{path}/{{experiment}}_{{method,Modseeker}}.scores".format(path = exp_path)
	shell:
		"{script_path}/calcModseeker {input} {output}"


def get_icSHAPE_input(wildcards):
	name = wildcards.experiment
	input_list = []

	if name == "icSHAPE_invitro":
		input_list = expand("{path}/{name}_{channel}_best_strata.bam", path = exp_path, name = "icSHAPE", channel = ["dmso", "invitro"])
	elif name == "icSHAPE_invivo":
		input_list = expand("{path}/{name}_{channel}_best_strata.bam", path = exp_path, name = "icSHAPE", channel = ["dmso", "invivo"])
	else:
		input_list = expand("{path}/{name}_{channel}_best_strata.bam", path = exp_path, name = name, channel = ["minus", "plus"])

	if name.startswith("structure_seq"):
		input_list.append(arabidopsis_filt + ".translist")
	elif name == "mod_seq" or name == "pseudo_seq":
		input_list.append(yeast_filt + ".translist")
	elif name == "ChemModSeq":
		input_list.append(yeast_rRNAs + ".translist")
	else:
		input_list.append(mouse_filt + ".translist")

	return input_list

rule calculate_icSHAPE_score:
	input: Samtools, get_icSHAPE_input
	output:
		"{path}/{{experiment}}_icSHAPE.scores".format(path = exp_path)
	shell:
		"{script_path}/run_icSHAPE {input} {exp_path}/{wildcards.experiment}_icSHAPE"

rule calculate_Pseudoseq_score:
	input: get_score_input
	output:
		"{path}/{{experiment}}_{{method,Pseudoseq}}.scores".format(path = exp_path)
	shell:
		"{script_path}/calcPseudoseq {input} {output}"




# RNA structure analysis


rule sort_bam_by_name: # Sort Bowtie alignments by name to avoid slightly different downstream analysis results
	input:
		"{path}/structure_seq_{{channel}}_all.bam".format(path = exp_path),
		RSEM_calculate
	output:
		"{path}/structure_seq_sorted_{{channel,(minus|plus)}}_all.bam".format(path = exp_path)
	threads: 20
	shell:
		"{rsem_path}/samtools-1.3/samtools sort -n -@ {threads} -o {output} {input[0]}"


## Collect mapping statistics

rule extract_mapping_statistics:
	input:
		"{path}/structure_seq_sorted_{{channel}}_all.bam".format(path = exp_path),
		"{path}/rRNA_list.txt".format(path = gt_path)
	output:
		"{path}/structure_seq_sorted_{{channel}}.stats.txt".format(path = exp_path)
	shell:
		"{script_path}/collectAlignStat {input[0]} {input[1]} > {output}"

rule generate_mapping_statistics_table:
	input:
		expand("{path}/structure_seq_sorted_{channel}.stats.txt", path = exp_path, channel = ["minus", "plus"])
	output:
		"{path}/mapping_statistics_table.txt".format(path = result_path)
	shell:
		"{script_path}/generate_mapping_statistics_table {input} {output}"


## Evaluate running time and memory usage

minus_reads = sample_name_to_data["structure_seq_minus"]
plus_reads = sample_name_to_data["structure_seq_plus"]

rule time_and_memory:
	input:
		arabidopsis_filt,
		plus_reads,
		minus_reads,
		PROBer, Bowtie
	output:
		expand("{path}/structure_seq_PROBer.{suffix}", path = exp_path, suffix = ["time", "bam.time", "mem"])
	threads: 20
	shell:
		"{PROBer} estimate --time --memory --for-paper --bowtie --bowtie-path {bowtie_path} -p {threads} --output-bam"
		" --read-length 37 --size-selection-min 21 --size-selection-max 526"
		" {input[0]} {exp_path}/structure_seq_PROBer --reads {input[1]},{input[2]} {input[3]},{input[4]}"


rule generate_time_and_memory_table:
	input:
	 	rules.time_and_memory.output
	output:
		"{path}/time_and_memory_table.txt".format(path = result_path)
	shell:
		"{script_path}/generate_time_memory_table {exp_path}/structure_seq_PROBer {output}"


## simuation results

rule run_PROBer_full_model:
	input:
		arabidopsis_filt,
		expand("{path}/structure_seq_sim{{digit}}_{channel}_all.bam", path = exp_path, channel = ["minus", "plus"]),
		PROBer_full_model
	params:
		"{path}/structure_seq_sim{{digit}}_full".format(path = exp_path)
	output:
		expand("{path}/structure_seq_sim{{digit,\d}}_full.{suffix}", path = exp_path, suffix = ["beta", "gamma", "expr"])
	threads: 20
	shell:
		"{PROBer_full_model} estimate -p {threads} --size-selection-min 21 --size-selection-max 526 --read-length 37 {input[0]} {params} --alignments {input[1]} {input[2]}"

rule run_RSEM_PROBer_star_pipeline:
	input:
		arabidopsis_filt_rsem,
		expand("{path}/structure_seq_sim{{digit}}_{channel}_all.bam", path = exp_path, channel = ["minus", "plus"]),
		"{path}/input_list_boxplot.txt".format(path = sim_path),
		PROBer_single, RSEM_calculate
	params: "{path}/structure_seq_sim{{digit}}_pipeline".format(path = exp_path)
	output: 
		expand("{path}/structure_seq_sim{{digit,\d}}_pipeline.{suffix}", path = exp_path, suffix = ["beta", "gamma"])
	threads: 20
	shell:
		"{PROBer_single} -p {threads} --input-list {input[3]} --RSEM-path {rsem_path} {input[0]} {params} --alignments {input[1]} {input[2]}"

rule produce_simulation_results:
	input:
		arabidopsis_filt,
		arabidopsis_filt + ".mappability",
		expand("{path}/ground_truth.{suffix}", path = sim_path, suffix = ["expr", "beta"]),
		expand("{path}/structure_seq_sim{{digit}}_{program}.beta", path = exp_path, program = ["PROBer", "full", "pipeline"]),
		expand("{path}/structure_seq_sim{{digit}}_{method}.scores", path = exp_path,
			method = ["StructureFold", "Modseeker", "icSHAPE"])
	params: "{path}/structure_seq_sim{{digit}}".format(path = exp_path)
	output:
		expand("{path}/structure_seq_sim{{digit,\d}}_{name}_{method}_melt.txt",
			path = exp_path, name = ["vs_full", "vs_pipeline", "main"], method = ["pearson", "spearman"])
	shell:
		"{script_path}/analyzeResAC {params}_vs_full_pearson plot pearson 36 {input[0]}.transcripts.fa {input[1]} {input[2]} {input[3]} {input[4]} {input[5]} && "
		"{script_path}/analyzeResAC {params}_vs_pipeline_pearson plot pearson 36 {input[0]}.transcripts.fa {input[1]} {input[2]} {input[3]} {input[4]} {input[6]} && "
		"{script_path}/analyzeResAC {params}_main_pearson plot pearson 36 {input[0]}.transcripts.fa {input[1]} {input[2]} {input[3]} {input[4]} {input[7]} {input[8]} {input[9]} && "
		"{script_path}/analyzeResAC {params}_vs_full_spearman plot spearman 36 {input[0]}.transcripts.fa {input[1]} {input[2]} {input[3]} {input[4]} {input[5]} && "
		"{script_path}/analyzeResAC {params}_vs_pipeline_spearman plot spearman 36 {input[0]}.transcripts.fa {input[1]} {input[2]} {input[3]} {input[4]} {input[6]} && "
		"{script_path}/analyzeResAC {params}_main_spearman plot spearman 36 {input[0]}.transcripts.fa {input[1]} {input[2]} {input[3]} {input[4]} {input[7]} {input[8]} {input[9]}"

rule produce_boxplot_pdf:
	input:
		"{path}/structure_seq_sim{{digit}}_{{name}}_melt.txt".format(path = exp_path)
	output:
		"{path}/structure_seq_sim{{digit,\d}}_{{name}}_boxplot.pdf".format(path = result_path)
	shell:
		"{script_path}/genBoxPlot {input} {output}"


## digital spike-in results

# rule produce_digital_spike_in_results:
# 	input:
# 		"{path}/ground_truth_spikes.beta".format(path = sim_path),
# 		expand("{path}/structure_seq_spikes_{TPM}_{method_suffix}", path = exp_path, TPM = ["1e2", "1e3", "1e4", "1e5"],
# 			method_suffix = ["PROBer.beta", "StructureFold.scores", "Modseq.scores", "icSHAPE.scores"])
# 	output:
# 		"{path}/digital_spike_in.txt".format(path = result_path)
# 	shell:
# 		"{script_path}/analyzeSpikes {input[0]} {exp_path}/structure_seq_spikes 36 {output}"

rule produce_digital_spike_in_results:
	input:
		"{path}/ground_truth_spikes.beta".format(path = sim_path),
		expand("{path}/structure_seq_spikes_{TPM}_{method_suffix}", path = exp_path, TPM = ["1e2", "1e3", "1e4", "1e5"],
			method_suffix = ["PROBer.beta", "StructureFold.scores", "Modseq.scores", "icSHAPE.scores"])
	output:
		"{path}/structure_seq_spikes_melt.txt".format(path = exp_path)
	shell:
		"{script_path}/analyzeResSpike {exp_path}/structure_seq_spikes pearson 36 {input[0]} 9"


## expression results

rule run_RSEM_for_scatter_plots:
	input:
		arabidopsis_filt_rsem,
		"{path}/structure_seq_simrsem_all.bam".format(path = exp_path),
		RSEM_calculate
	params: "{path}/structure_seq_simrsem_RSEM".format(path = exp_path)
	output: 
		"{path}/structure_seq_simrsem_RSEM.isoforms.results".format(path = exp_path)
	threads: 20
	shell:
		"{RSEM_calculate} -p {threads} --alignments --strand-specific --no-bam-output {input[1]} {input[0]} {params}"

rule generate_expression_scatter_plots:
	input:
		"{path}/ground_truth.expr".format(path = sim_path),
		"{path}/structure_seq_sim1_PROBer.expr".format(path = exp_path),
		expand("{path}/structure_seq_sim1_pipeline_{channel}.isoforms.results", path = exp_path, channel = ["minus", "plus"]),
		rules.run_RSEM_for_scatter_plots.output
	output:
		"{path}/scatters.pdf".format(path = result_path)
	shell:
		"{script_path}/genExprScatterPlots {input} {output}"


## PR, ROC curves for yeast data sets

rule generate_mod_seq_PR_ROC_sasa:
	input:
		expand("{path}/yeast_{rRNA}.{suffix}", path = gt_path, rRNA = ["18S", "25S"], suffix = ["structure", "isac", "sasa"]),
		expand("{path}/mod_seq_{method_suffix}", path = exp_path, method_suffix = ["PROBer.beta", "Modseeker.scores", "icSHAPE.scores"])
	output:
		expand("{path}/mod_seq_{type}_{rRNA}.pdf", path = result_path, type = ["pr", "roc"], rRNA = ["18S", "25S"])
	shell:
		"{script_path}/plot_PR_ROC_sasa {gt_path} 36,37 49 {exp_path}/mod_seq {result_path}/mod_seq"

# mate length is 49 nt
rule generate_ChemModSeq_PR_ROC_sasa:
	input:
		expand("{path}/yeast_{rRNA}.{suffix}", path = gt_path, rRNA = ["18S", "25S"], suffix = ["structure", "isac", "sasa"]),
		expand("{path}/ChemModSeq_{method_suffix}", path = exp_path, method_suffix = ["PROBer.beta", "StructureFold.scores", "Modseeker.scores", "icSHAPE.scores"])
	output:
		expand("{path}/ChemModSeq_{type}_{rRNA}.pdf", path = result_path, type = ["pr", "roc"], rRNA = ["18S", "25S"])
	shell:
		"{script_path}/plot_PR_ROC_sasa {gt_path} 1,2 48 {exp_path}/ChemModSeq {result_path}/ChemModSeq"

## Structure prediction using RNAstructure for yeast data sets

method2suf_SP = {"PROBer" : "beta", "StructureFold" : "scores", "Modseeker" : "scores", "icSHAPE" : "icSHAPE"}

def get_input_SP(wildcards):
	return "{path}/{experiment}_{method}.{suffix}".format(path = exp_path, 
		experiment = wildcards.experiment, method = wildcards.method, suffix = method2suf_SP[wildcards.method])

exp2ebp_SP = {"mod_seq" : "49", "ChemModSeq" : "48"}
er2tid_SP = {("mod_seq", "18S") : "36", ("mod_seq", "25S") : "37",
			 ("ChemModSeq", "18S") : "1", ("ChemModSeq", "25S") : "2"}
er2RNA_SP = {("mod_seq", "18S") : "RDN18-1", ("mod_seq", "25S") : "RDN25-1",
			 ("ChemModSeq", "18S") : "18S_rRNA", ("ChemModSeq", "25S") : "25S_rRNA"}

def get_params_SP(wildcards):
	res = ""
	if wildcards.method != "icSHAPE":
		res = er2tid_SP[wildcards.experiment, wildcards.rRNA]
	else:
		res = er2RNA_SP[wildcards.experiment, wildcards.rRNA]
	res += " " + exp2ebp_SP[wildcards.experiment]

	return res

rule extractReactivity:
	input:	
		get_input_SP,
		"{path}/yeast_{{rRNA}}.valid".format(path = gt_path)
	params: get_params_SP
	output: 
		"{path}/{{experiment}}_{{rRNA,(18S|25S)}}_{{method,(PROBer|StructureFold|Modseeker|icSHAPE)}}.shape".format(path = exp_path)
	shell:
		"{script_path}/score2shape {input[0]} {output} {params} {input[1]}"

rule runRNAstructure:
	input:
		"{path}/yeast_{{rRNA}}.fa".format(path = gt_path),
		"{path}/{{experiment}}_{{rRNA}}_{{method}}.shape".format(path = exp_path),
		Fold
	output: 
		"{path}/{{experiment}}_{{rRNA,(18S|25S)}}_{{method,(PROBer|StructureFold|Modseeker|icSHAPE)}}.ct"
	shell:
		"export DATAPATH={RNAstructure_data_path} && {Fold} {input[0]} {output} -sh {input[1]}"

rule runRNAstructure_baseline:
	input:
		"{path}/yeast_{{rRNA}}.fa".format(path = gt_path),
		Fold
	output: 
		"{path}/yeast_{{rRNA,(18S|25S)}}_baseline.ct".format(path = exp_path)
	shell:
		"export DATAPATH={RNAstructure_data_path} && {Fold} {input[0]} {output}"

rule evaluate_structure:
	input: 
		"{path}/{{experiment}}_{{rRNA}}_{{method}}.ct".format(path = exp_path),
		"{path}/yeast_{{rRNA}}.ct".format(path = gt_path)
	output:
		"{path}/{{experiment}}_{{rRNA,(18S|25S)}}_{{method,(PROBer|StructureFold|Modseeker|icSHAPE|baseline)}}.eval".format(path = exp_path)
	shell:
		"{scorer} {input} {output}"


## ROC curves for a variety of data sets

### structure-seq data
# rule generate_structure_seq_ROC_plots:
# 	input:
# 		expand("{path}/arabidopsis_{name}.{suffix}", path = gt_path, name = ["18S", "25S"], suffix = ["structure", "isac"]),
# 		expand("{path}/structure_seq_{method_suffix}", path = exp_path,
# 			method_suffix = ["sorted_PROBer.beta", "StructureFold.scores", "Modseq.scores", "icSHAPE.scores"])
# 	output:
# 		expand("{path}/structure_seq_roc_{name}.pdf", path = result_path, name = ["18S", "25S"])
# 	shell:
# 		"{script_path}/plotROC {gt_path} 36 {exp_path}/structure_seq {result_path}/structure_seq_roc"

# ### Mod-seq data
# rule generate_mod_seq_ROC_plots:
# 	input:
# 		expand("{path}/yeast_{name}.{suffix}", path = gt_path, name = ["18S", "25S"], suffix = ["structure", "isac"]),
# 		expand("{path}/mod_seq_{method_suffix}", path = exp_path,
# 			method_suffix = ["PROBer.beta", "Modseq.scores", "icSHAPE.scores"])
# 	output:
# 		expand("{path}/mod_seq_roc_{name}.pdf", path = result_path, name = ["18S", "25S"])
# 	shell:
# 		"{script_path}/plotROC {gt_path} 49 {exp_path}/mod_seq {result_path}/mod_seq_roc"

# ### icSHAPE data
# rule generate_icSHAPE_ROC_plots:
# 	input:
# 		expand("{path}/mouse_{name}.{suffix}", path = gt_path, name = ["18S", "12S_Mt"], suffix = ["structure", "isac"]),
# 		expand("{path}/icSHAPE_{{condition}}_{method_suffix}", path = exp_path,
# 			method_suffix = ["PROBer.beta", "StructureFold.scores", "Modseq.scores", "icSHAPE.scores"])
# 	output:
# 		expand("{path}/icSHAPE_{{condition,(invitro|invivo)}}_roc_{name}.pdf", path = result_path, name = ["18S", "12S_Mt"])
# 	shell:
# 		"{script_path}/plotROC {gt_path} 86 {exp_path}/icSHAPE_{wildcards.condition} {result_path}/icSHAPE_{wildcards.condition}_roc"




# Pseudo-seq experiments for Pseudouridine modification


rule generate_pseudoU_PR_ROC_plots:
	input:
		yeast_filt,
		expand("{path}/{name}.truth", path = gt_path, name = ["18S", "25S", "5S", "58S", "LSR1"]),
		expand("{path}/pseudo_seq_{method_suffix}", path = exp_path,
			method_suffix = ["PROBer.beta", "Pseudoseq.scores", "StructureFold.scores", "Modseq.scores", "icSHAPE.scores"])
	output:
		expand("{path}/pseudoU_{type}.pdf", path = result_path, type = ["PR", "ROC"])
	shell:
		"{script_path}/plot_PR_ROC {input[0]}.transcripts.fa {gt_path} {exp_path}/pseudo_seq {result_path}/pseudoU"

rule visualize_18S_for_pseudoU_experiment:
	input:
		"{path}/18S.truth".format(path = gt_path),
		"{path}/pseudo_seq_PROBer.beta".format(path = exp_path),
		expand("{path}/pseudo_seq_{method}.scores", path = exp_path, method = ["Pseudoseq", "StructureFold", "Modseq", "icSHAPE"])
	output:
		"{path}/pseudoU_18S.pdf".format(path = result_path)
	shell:
		"{script_path}/plotPseudoUScore {input} 36 1,500,1000,1191,1500,1800 \"18S rRNA\" {output}"

# iCLIP


rule bowtie_align_to_genome:
	input:
		human_ref,
		"{path}/SRR3147675_cleaned.fq".format(path = YeoLab),
		Bowtie, Samtools
	output:
		"{path}/RBFOX2_iCLIP.bam".format(path = exp_path)
	log:
		"{path}/RBFOX2_iCLIP.log".format(path = exp_path)
	threads: 20
	shell:
		"{Bowtie} -a -m 100 --chunkmbs 1024 -p {threads} -S {input[0]} {input[1]} 2> {log} | {Samtools} view -S -b -o {output} -"

rule generate_iCLIP_mapping_statistics_table:
	input:
		rules.bowtie_align_to_genome.output
	output:
		"{path}/iCLIP_mapping_statistics.txt".format(path = result_path)
	shell:
		"echo -e 'Unique\tMulti-mapping\tUnalignable\tFiltered' > {output} && "
		"{script_path}/collectAlignStat {input} None >> {output}"

rule run_PROBer_iCLIP:
	input:
		rules.bowtie_align_to_genome.output,
		PROBer
	params: 
		"{path}/RBFOX2_iCLIP_res".format(path = exp_path)
	output:
		"{path}/RBFOX2_iCLIP_res.site_info".format(path = exp_path)
	threads: 20
	shell:
		"{PROBer} iCLIP -p {threads} {params} --alignments {input[0]}"

rule run_iCLIP_baseline:
	input:
		rules.bowtie_align_to_genome.output,
		PROBer
	params: 
		"{path}/RBFOX2_iCLIP_naive".format(path = exp_path)
	output:
		"{path}/RBFOX2_iCLIP_naive.site_info".format(path = exp_path)
	threads: 20
	shell:
		"{PROBer} iCLIP -p {threads} --naive {params} --alignments {input[0]}"

rule detect_motif:
	input:
		"{path}/detectMotif".format(path = script_path),
		"{path}/Homo_sapiens.GRCh38.dna.primary_assembly.fa".format(path = ref_human),
		rules.run_PROBer_iCLIP.output
	output:
		"{path}/RBFOX2_iCLIP.10.motifs".format(path = exp_path)
	shell:
		"{input[0]} {input[1]} TGCATG 10 {input[2]} {output}"

rule calculate_motif_rate:
	input:
		"{path}/calcMotifRate".format(path = script_path),
		rules.detect_motif.output,
		rules.run_PROBer_iCLIP.output,
		rules.run_iCLIP_baseline.output
	output:
		"{path}/RBFOX2_iCLIP_table.txt".format(path = result_path)
	shell:
		"{input[0]} 10 10.0 {input[1]} {input[2]} {input[3]} {output}"

rule generate_BedGraph:
	input:
		rules.run_PROBer_iCLIP.output
	output:
		expand("{path}/{name}.bedGraph", path = result_path, name = "NUP133")
	shell:
		"{script_path}/generateBedGraph 1 - 229470242 229470387 {input} {output[0]}"

# rule generate_BedGraph:
# 	input:
# 		rules.run_PROBer_iCLIP.output
# 	output:
# 		expand("{path}/{name}.bedGraph", path = result_path, name = ["SRGAP2B", "SRGAP2D"])
# 	shell:
# 		"{script_path}/generateBedGraph 1 - 145089359 145089504 {input} {output[0]} && "
# 		"{script_path}/generateBedGraph 1 + 143978486 143978631 {input} {output[1]}"
