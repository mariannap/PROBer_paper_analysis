import re

# Shared

def get_ref(wildcards):
	ref_name = ""
	name = wildcards.sample if hasattr(wildcards, "sample") else wildcards.experiment

	if name.startswith("structure_seq_spike"):
		ref_name = arabidopsis_spike
	elif name.startswith("structure_seq"):
		ref_name = arabidopsis_filt
	elif name.startswith("mod_seq") or name.startswith("pseudo_seq"):
		ref_name = yeast_filt
	elif name.startswith("icSHAPE"):
		ref_name = mouse_filt
	elif name.startswith("ChemModSeq"):
		ref_name = yeast_rRNAs
	elif name.startswith("SHAPES"):
		ref_name = ecoli_rRNA
	else:
		assert False

	return ref_name

def get_data_as_input(wildcards):
	if re.search("(sim|spike)", wildcards.sample):
		return ["{path}/{sample}.fq".format(path = sim_path, sample = wildcards.sample)]
	return sample_name_to_data.get(wildcards.sample, "None")

def get_data_as_param(wildcards):
	return ",".join(get_data_as_input(wildcards))

def get_bowtie_params(wildcards):
	if wildcards.sample.startswith("structure_seq"):
		return "-v 3"
	return "--chunkmbs 500"


rule bowtie_alignment_all:
	input: get_ref, get_data_as_input, Bowtie, Samtools
	params: bowtie = get_bowtie_params, data = get_data_as_param
	output:
		"{path}/{{sample,(structure_seq|mod_seq|pseudo_seq|icSHAPE)\w+}}_all.bam".format(path = exp_path)
	log:
		"{path}/{{sample}}_all.log".format(path = exp_path)
	threads: 20
	shell:
		"{Bowtie} --norc {params.bowtie} -a -m 200 -p {threads} -S {input[0]} {params.data} 2> {log} | {Samtools} view -S -b -o {output} -"

rule bowtie_alignment_best_strata:
	input: get_ref, get_data_as_input, Bowtie, Samtools
	params: bowtie = get_bowtie_params, data = get_data_as_param
	output:
		"{path}/{{sample,(structure_seq|mod_seq|pseudo_seq|icSHAPE)\w+}}_best_strata.bam".format(path = exp_path)
	log:
		"{path}/{{sample}}_best_strata.log".format(path = exp_path)
	threads: 20
	shell:
		"{Bowtie} --norc {params.bowtie} -a --best --strata -p {threads} -S {input[0]} {params.data} 2> {log} | {Samtools} view -S -b -o {output} -"

rule bowtie_alignment_best:
	input: get_ref, get_data_as_input, Bowtie, Samtools
	params: bowtie = get_bowtie_params, data = get_data_as_param
	output:
		"{path}/{{sample,(structure_seq|mod_seq|pseudo_seq|icSHAPE)\w+}}_best.bam".format(path = exp_path)
	log:
		"{path}/{{sample}}_best.log".format(path = exp_path)
	threads: 20
	shell:
		"{Bowtie} --norc {params.bowtie} --best -p {threads} -S {input[0]} {params.data} 2> {log} | {Samtools} view -S -b -o {output} -"


def get_mate1(wildcards):
	if wildcards.sample == "ChemModSeq_minus":
		return ",".join(["{path}/{run}_cleaned_1.fq".format(path = GrannemanLab, run = run) for run in ["SRR1041324", "SRR1041325", "SRR1041326"]])
	else:
		return ",".join(["{path}/{run}_cleaned_1.fq".format(path = GrannemanLab, run = run) for run in ["SRR1041327", "SRR1041328", "SRR1041329"]])

def get_mate2(wildcards):
	if wildcards.sample == "ChemModSeq_minus":
		return ",".join(["{path}/{run}_cleaned_2.fq".format(path = GrannemanLab, run = run) for run in ["SRR1041324", "SRR1041325", "SRR1041326"]])
	else:
		return ",".join(["{path}/{run}_cleaned_2.fq".format(path = GrannemanLab, run = run) for run in ["SRR1041327", "SRR1041328", "SRR1041329"]])

rule bowtie2_alignment_all:
	input: get_ref, get_data_as_input, Bowtie2, Samtools
	params: mate1 = get_mate1, mate2 = get_mate2
	output:
		"{path}/{{sample,ChemModSeq\w+}}_all.bam".format(path = exp_path)
	log:
		"{path}/{{sample}}_all.log".format(path = exp_path)
	threads: 20
	shell:
		"bowtie2 --norc -a -p {threads} -I 1 -X 700 --no-mixed --no-discordant -x {input[0]} -1 {params.mate1} -2 {params.mate2} 2> {log} | {Samtools} view -S -b -o {output} -"

rule bowtie2_alignment_best_strata:
	input: get_ref, get_data_as_input, Bowtie2, Samtools
	params: mate1 = get_mate1, mate2 = get_mate2
	output:
		"{path}/{{sample,ChemModSeq\w+}}_best_strata.bam".format(path = exp_path)
	log:
		"{path}/{{sample}}_best_strata.log".format(path = exp_path)
	threads: 20
	shell:
		"bowtie2 --norc -p {threads} -I 1 -X 700 --no-mixed --no-discordant -x {input[0]} -1 {params.mate1} -2 {params.mate2} 2> {log} | {Samtools} view -S -b -o {output} -"

rule bowtie2_alignment_best:
	input: get_ref, get_data_as_input, Bowtie2, Samtools
	params: mate1 = get_mate1, mate2 = get_mate2
	output:
		"{path}/{{sample,ChemModSeq\w+}}_best.bam".format(path = exp_path)
	log:
		"{path}/{{sample}}_best.log".format(path = exp_path)
	threads: 20
	shell:
		"bowtie2 --norc -k 1 -p {threads} -I 1 -X 700 --no-mixed --no-discordant -x {input[0]} -1 {params.mate1} -2 {params.mate2} 2> {log} | {Samtools} view -S -b -o {output} -"


ruleorder: sort_bam_by_name > bowtie_alignment_all


def get_PROBer_params(wildcards):
	params = ""
	if wildcards.experiment.startswith("structure_seq"):
		params = "--size-selection-min 21 --size-selection-max 526 --read-length 37"
	elif wildcards.experiment.startswith("mod_seq"):
		params = "--primer-length 0 --size-selection-min 23 --size-selection-max 220 --read-length 50"
	elif wildcards.experiment.startswith("pseudo_seq"):
		params = "--primer-length 0 --size-selection-min 18 --size-selection-max 130 --read-length 41"
	elif wildcards.experiment.startswith("ChemModSeq"):
		params = "--paired-end --size-selection-min 18 --size-selection-max 700"
	elif wildcards.experiment.startswith("SHAPES"):
		params = "--paired-end --size-selection-min 10 --size-selection-max 700"
	elif wildcards.experiment.startswith("icSHAPE"):
		params = "--primer-length 0 --size-selection-min 20 --size-selection-max 120 --read-length 87"
	else:
		assert False

	return params


rule run_PROBer:
	input:
		get_ref,
		expand("{path}/{{experiment}}_{channel}_all.bam", path = exp_path, channel = ["plus", "minus"]),
		PROBer
	params: get_PROBer_params
	output:
		expand("{path}/{{experiment}}_PROBer.{suffix}", path = exp_path, suffix = ["beta", "gamma", "expr"]),
		expand("{path}/{{experiment}}_PROBer.stat/{{experiment}}_PROBer_{channel}.{suffix}",
			path = exp_path, channel = ["minus", "plus"], suffix = ["read_model", "theta"])
	threads: 20
	shell:
		"{PROBer} estimate -p {threads} {params} {input[0]} {exp_path}/{wildcards.experiment}_PROBer --alignments {input[1]} {input[2]}"

rule run_PROBer_no_control:
	input:
		get_ref,
		expand("{path}/{{experiment}}_{{condition}}_all.bam", path = exp_path),
		PROBer
	params: get_PROBer_params
	output:
		expand("{path}/{{experiment,(icSHAPE|SHAPES_trimmed)}}_{{condition}}_PROBer.{suffix}", path = exp_path, suffix = ["beta", "expr"])
	threads: 20
	shell:
		"{PROBer} estimate -p {threads} {params} {input[0]} {exp_path}/{wildcards.experiment}_{wildcards.condition}_PROBer --alignments {input[1]}"

ruleorder: run_PROBer_no_control > run_PROBer


def get_score_input(wildcards):
	name = wildcards.experiment
	channels = ["minus", "plus"]
	if name == "icSHAPE_invitro":
		name = "icSHAPE"
		channels = ["dmso", "invitro"]
	elif name == "icSHAPE_invivo":
		name = "icSHAPE"
		channels = ["dmso", "invivo"]

	input_list = expand("{path}/{name}_{channel}_{method}.counts", 
						path = exp_path, name = name, channel = channels, method = wildcards.method)

	return input_list


rule extract_count_vector_StructureFold_or_Pseudoseq:
	input:
		"{path}/{{sample}}_best_strata.bam".format(path = exp_path)
	output:
		"{path}/{{sample}}_{{method,(StructureFold|Pseudoseq)}}.counts".format(path = exp_path)
	shell:
		"{script_path}/extractCountVectors {input} {output} 1 all"

rule calculate_StructureFold_score:
	input: get_score_input
	output:
		"{path}/{{experiment}}_{{method,StructureFold}}.scores".format(path = exp_path)
	shell:
		"{script_path}/calcStructureFold {input} {output}"

rule extract_count_vector_Modseeker:
	input:
		"{path}/{{sample}}_best.bam".format(path = exp_path)
	output:
		"{path}/{{sample}}_Modseeker.counts".format(path = exp_path)
	shell:
		"{script_path}/extractCountVectors {input} {output} 0 all"

rule calculate_Modseq_score:
	input: get_score_input
	output:
		"{path}/{{experiment}}_{{method,Modseeker}}.scores".format(path = exp_path)
	shell:
		"{script_path}/calcModseeker {input} {output}"


def get_icSHAPE_input(wildcards):
	name = wildcards.experiment
	input_list = []

	if name == "icSHAPE_invitro":
		input_list = expand("{path}/{name}_{channel}_best_strata.bam", path = exp_path, name = "icSHAPE", channel = ["dmso", "invitro"])
	elif name == "icSHAPE_invivo":
		input_list = expand("{path}/{name}_{channel}_best_strata.bam", path = exp_path, name = "icSHAPE", channel = ["dmso", "invivo"])
	else:
		input_list = expand("{path}/{name}_{channel}_best_strata.bam", path = exp_path, name = name, channel = ["minus", "plus"])

	if name.startswith("structure_seq_spikes"):
		input_list.append(arabidopsis_spike + ".translist")
	elif name.startswith("structure_seq"):
		input_list.append(arabidopsis_filt + ".translist")
	elif name == "mod_seq" or name == "pseudo_seq":
		input_list.append(yeast_filt + ".translist")
	elif name == "ChemModSeq":
		input_list.append(yeast_rRNAs + ".translist")
	else:
		input_list.append(mouse_filt + ".translist")

	return input_list

rule calculate_icSHAPE_score:
	input: Samtools, get_icSHAPE_input
	output:
		"{path}/{{experiment}}_icSHAPE.scores".format(path = exp_path)
	shell:
		"{script_path}/run_icSHAPE {input} {exp_path}/{wildcards.experiment}_icSHAPE"

rule calculate_Pseudoseq_score:
	input: get_score_input
	output:
		"{path}/{{experiment}}_{{method,Pseudoseq}}.scores".format(path = exp_path)
	shell:
		"{script_path}/calcPseudoseq {input} {output}"




# RNA structure analysis


rule sort_bam_by_name: # Sort Bowtie alignments by name to avoid slightly different downstream analysis results
	input:
		"{path}/structure_seq_{{channel}}_all.bam".format(path = exp_path),
		RSEM_calculate
	output:
		"{path}/structure_seq_sorted_{{channel,(minus|plus)}}_all.bam".format(path = exp_path)
	threads: 20
	shell:
		"{rsem_path}/samtools-1.3/samtools sort -n -@ {threads} -o {output} {input[0]}"


## Collect mapping statistics

rule extract_structure_seq_mapping_statistics:
	input:
		"{path}/structure_seq_sorted_{{channel}}_all.bam".format(path = exp_path),
		"{path}/rRNA_list.txt".format(path = gt_path)
	output:
		"{path}/structure_seq_sorted_{{channel,(minus|plus)}}.stats.txt".format(path = exp_path)
	shell:
		"{script_path}/collectAlignStat {input[0]} {input[1]} > {output}"

rule extract_RBFOX2_eCLIP_mapping_statistics:
	input:
		"{path}/RBFOX2_293T_YeoLab_{{rep}}.alignments.bam".format(path = exp_path)
	output:
		"{path}/RBFOX2_eCLIP_{{rep,(rep1|input)}}.stats.txt".format(path = exp_path)
	shell:
		"{script_path}/collectAlignStat {input} None > {output}"

rule generate_mapping_statistics_table:
	input:
		expand("{path}/structure_seq_sorted_{channel}.stats.txt", path = exp_path, channel = ["plus", "minus"]),
		expand("{path}/RBFOX2_eCLIP_{rep}.stats.txt", path = exp_path, rep = ["rep1", "input"])
	output:
		"{path}/mapping_statistics_table.txt".format(path = result_path)
	shell:
		"{script_path}/generate_mapping_statistics_table {input} {output}"


## Evaluate running time and memory usage

minus_reads = sample_name_to_data["structure_seq_minus"]
plus_reads = sample_name_to_data["structure_seq_plus"]

rule run_PROBer_for_time_and_memory:
	input:
		arabidopsis_filt,
		plus_reads,
		minus_reads,
		PROBer, Bowtie
	output:
		expand("{path}/structure_seq_PROBer.{suffix}", path = exp_path, suffix = ["time", "bam.time", "mem"])
	threads: 20
	shell:
		"{PROBer} estimate --time --memory --for-paper --bowtie --bowtie-path {bowtie_path} -p {threads} --output-bam"
		" --read-length 37 --size-selection-min 21 --size-selection-max 526"
		" {input[0]} {exp_path}/structure_seq_PROBer --reads {input[1]},{input[2]} {input[3]},{input[4]}"


rule generate_time_and_memory_table:
	input:
	 	expand("{path}/structure_seq_PROBer.{suffix}", path = exp_path, suffix = ["time", "bam.time", "mem"]),
	 	expand("{path}/RBFOX2_293T_YeoLab_rep1.{suffix}", path = exp_path, suffix = ["time", "mem"])
	output:
		"{path}/time_and_memory_table.txt".format(path = result_path)
	shell:
		"{script_path}/generate_time_memory_table {exp_path}/structure_seq_PROBer {exp_path}/RBFOX2_293T_YeoLab_rep1 {output}"


## simuation results

rule run_PROBer_full_model:
	input:
		arabidopsis_filt,
		expand("{path}/structure_seq_sim{{digit}}_{channel}_all.bam", path = exp_path, channel = ["minus", "plus"]),
		PROBer_full_model
	params:
		"{path}/structure_seq_sim{{digit}}_full".format(path = exp_path)
	output:
		expand("{path}/structure_seq_sim{{digit,\d}}_full.{suffix}", path = exp_path, suffix = ["beta", "gamma", "expr"])
	threads: 20
	shell:
		"{PROBer_full_model} estimate -p {threads} --size-selection-min 21 --size-selection-max 526 --read-length 37 {input[0]} {params} --alignments {input[1]} {input[2]}"

rule run_RSEM_PROBer_star_pipeline:
	input:
		arabidopsis_filt_rsem,
		expand("{path}/structure_seq_sim{{digit}}_{channel}_all.bam", path = exp_path, channel = ["minus", "plus"]),
		"{path}/input_list_boxplot.txt".format(path = sim_path),
		PROBer_single, RSEM_calculate
	params: "{path}/structure_seq_sim{{digit}}_pipeline".format(path = exp_path)
	output: 
		expand("{path}/structure_seq_sim{{digit,\d}}_pipeline.{suffix}", path = exp_path, suffix = ["beta", "gamma"])
	threads: 20
	shell:
		"{PROBer_single} -p {threads} --input-list {input[3]} --RSEM-path {rsem_path} {input[0]} {params} --alignments {input[1]} {input[2]}"

rule produce_simulation_results:
	input:
		arabidopsis_filt,
		arabidopsis_filt + ".mappability",
		expand("{path}/ground_truth.{suffix}", path = sim_path, suffix = ["expr", "beta"]),
		expand("{path}/structure_seq_sim{{digit}}_{program}.beta", path = exp_path, program = ["PROBer", "full", "pipeline"]),
		expand("{path}/structure_seq_sim{{digit}}_{method}.scores", path = exp_path,
			method = ["StructureFold", "Modseeker", "icSHAPE"])
	params: "{path}/structure_seq_sim{{digit}}".format(path = exp_path)
	output:
		expand("{path}/structure_seq_sim{{digit,\d}}_{name}_{corr}_melt.txt",
			path = exp_path, name = ["vs_full", "vs_pipeline", "main"], corr = ["pearson", "spearman"])
	shell:
		"{script_path}/analyzeResAC {params}_vs_full_pearson plot pearson 36 {input[0]}.transcripts.fa {input[1]} {input[2]} {input[3]} {input[4]} {input[5]} && "
		"{script_path}/analyzeResAC {params}_vs_pipeline_pearson plot pearson 36 {input[0]}.transcripts.fa {input[1]} {input[2]} {input[3]} {input[4]} {input[6]} && "
		"{script_path}/analyzeResAC {params}_main_pearson plot pearson 36 {input[0]}.transcripts.fa {input[1]} {input[2]} {input[3]} {input[4]} {input[7]} {input[8]} {input[9]} && "
		"{script_path}/analyzeResAC {params}_vs_full_spearman plot spearman 36 {input[0]}.transcripts.fa {input[1]} {input[2]} {input[3]} {input[4]} {input[5]} && "
		"{script_path}/analyzeResAC {params}_vs_pipeline_spearman plot spearman 36 {input[0]}.transcripts.fa {input[1]} {input[2]} {input[3]} {input[4]} {input[6]} && "
		"{script_path}/analyzeResAC {params}_main_spearman plot spearman 36 {input[0]}.transcripts.fa {input[1]} {input[2]} {input[3]} {input[4]} {input[7]} {input[8]} {input[9]}"

rule produce_boxplot_pdf:
	input:
		"{path}/structure_seq_sim{{digit}}_{{name}}_melt.txt".format(path = exp_path)
	output:
		"{path}/structure_seq_sim{{digit,\d}}_{{name}}_boxplot.pdf".format(path = result_path)
	shell:
		"{script_path}/genBoxPlot {input} {output}"


## digital spike-in results

rule produce_digital_spike_in_results:
	input:
		"{path}/ground_truth_spikes.beta".format(path = sim_path),
		expand("{path}/structure_seq_spikes_{TPM}_{method_suffix}", path = exp_path, TPM = ["1e2", "1e3", "1e4", "1e5"],
			method_suffix = ["PROBer.beta", "StructureFold.scores", "Modseeker.scores", "icSHAPE.scores"])
	output:
		expand("{path}/structure_seq_spikes_{corr}_melt.txt", path = exp_path, corr = ["pearson", "spearman"])
	shell:
		"{script_path}/analyzeResSpike {exp_path}/structure_seq_spikes pearson 36 {input[0]} 9 && "
		"{script_path}/analyzeResSpike {exp_path}/structure_seq_spikes spearman 36 {input[0]} 9"

rule produce_boxplot_pdf_for_spike_in_experiments:
	input:
		"{path}/structure_seq_spikes_{{corr}}_melt.txt".format(path = exp_path)
	output:
		"{path}/structure_seq_spikes_{{corr,(pearson|spearman)}}_boxplot.pdf".format(path = result_path)
	shell:
		"{script_path}/genBoxPlotSpikes {input} {output}"

## expression results

rule run_RSEM_for_scatter_plots:
	input:
		arabidopsis_filt_rsem,
		"{path}/structure_seq_simrsem_all.bam".format(path = exp_path),
		RSEM_calculate
	params: "{path}/structure_seq_simrsem_RSEM".format(path = exp_path)
	output: 
		"{path}/structure_seq_simrsem_RSEM.isoforms.results".format(path = exp_path)
	threads: 20
	shell:
		"{RSEM_calculate} -p {threads} --alignments --strand-specific --no-bam-output {input[1]} {input[0]} {params}"

rule generate_expression_scatter_plots:
	input:
		"{path}/ground_truth.expr".format(path = sim_path),
		"{path}/structure_seq_sim1_PROBer.expr".format(path = exp_path),
		expand("{path}/structure_seq_sim1_pipeline_{channel}.isoforms.results", path = exp_path, channel = ["minus", "plus"]),
		rules.run_RSEM_for_scatter_plots.output
	output:
		"{path}/scatters.pdf".format(path = result_path)
	shell:
		"{script_path}/genExprScatterPlots {input} {output}"


## PR, ROC curves for yeast data sets

rule generate_mod_seq_PR_ROC_sasa:
	input:
		expand("{path}/yeast_{rRNA}.{suffix}", path = gt_path, rRNA = ["18S", "25S"], suffix = ["structure", "isac", "sasa"]),
		expand("{path}/mod_seq_{method_suffix}", path = exp_path, method_suffix = ["PROBer.beta", "Modseeker.scores", "icSHAPE.scores"])
	output:
		expand("{path}/mod_seq_{type}_{rRNA}.pdf", path = result_path, type = ["pr", "roc"], rRNA = ["18S", "25S"])
	shell:
		"{script_path}/plot_PR_ROC_sasa {gt_path} 36,37 49 {exp_path}/mod_seq {result_path}/mod_seq"

# mate length is 49 nt
rule generate_ChemModSeq_PR_ROC_sasa:
	input:
		expand("{path}/yeast_{rRNA}.{suffix}", path = gt_path, rRNA = ["18S", "25S"], suffix = ["structure", "isac", "sasa"]),
		expand("{path}/ChemModSeq_{method_suffix}", path = exp_path, method_suffix = ["PROBer.beta", "StructureFold.scores", "Modseeker.scores", "icSHAPE.scores"])
	output:
		expand("{path}/ChemModSeq_{type}_{rRNA}.pdf", path = result_path, type = ["pr", "roc"], rRNA = ["18S", "25S"])
	shell:
		"{script_path}/plot_PR_ROC_sasa {gt_path} 1,2 48 {exp_path}/ChemModSeq {result_path}/ChemModSeq"


## Structure prediction using RNAstructure for yeast data sets

method2suf_SP = {"PROBer" : "beta", "StructureFold" : "scores", "Modseeker" : "scores", "icSHAPE" : "icSHAPE"}

def get_input_SP(wildcards):
	return "{path}/{experiment}_{method}.{suffix}".format(path = exp_path, 
		experiment = wildcards.experiment, method = wildcards.method, suffix = method2suf_SP[wildcards.method])

exp2ebp_SP = {"mod_seq" : "49", "ChemModSeq" : "48"}
er2tid_SP = {("mod_seq", "18S") : "36", ("mod_seq", "25S") : "37",
			 ("ChemModSeq", "18S") : "1", ("ChemModSeq", "25S") : "2"}
er2RNA_SP = {("mod_seq", "18S") : "RDN18-1", ("mod_seq", "25S") : "RDN25-1",
			 ("ChemModSeq", "18S") : "18S_rRNA", ("ChemModSeq", "25S") : "25S_rRNA"}

def get_params_SP(wildcards):
	res = ""
	if wildcards.method != "icSHAPE":
		res = er2tid_SP[wildcards.experiment, wildcards.rRNA]
	else:
		res = er2RNA_SP[wildcards.experiment, wildcards.rRNA]
	res += " " + exp2ebp_SP[wildcards.experiment]

	return res

rule extractReactivity:
	input:	
		get_input_SP,
		"{path}/yeast_{{rRNA}}.valid".format(path = gt_path)
	params: get_params_SP
	output: 
		"{path}/{{experiment}}_{{rRNA,(18S|25S)}}_{{method,(PROBer|StructureFold|Modseeker|icSHAPE)}}.shape".format(path = exp_path)
	shell:
		"{script_path}/score2shape {input[0]} {output} {params} {input[1]}"

rule runRNAstructure:
	input:
		"{path}/yeast_{{rRNA}}.fa".format(path = gt_path),
		"{path}/{{experiment}}_{{rRNA}}_{{method}}.shape".format(path = exp_path),
		Fold
	output: 
		"{path}/{{experiment}}_{{rRNA,(18S|25S)}}_{{method,(PROBer|StructureFold|Modseeker|icSHAPE)}}.ct".format(path = exp_path)
	shell:
		"export DATAPATH={RNAstructure_data_path} && {Fold} {input[0]} {output} -sh {input[1]}"

rule runRNAstructure_baseline:
	input:
		"{path}/yeast_{{rRNA}}.fa".format(path = gt_path),
		Fold
	output: 
		"{path}/yeast_{{rRNA,(18S|25S)}}_baseline.ct".format(path = exp_path)
	shell:
		"export DATAPATH={RNAstructure_data_path} && {Fold} {input[0]} {output}"

rule evaluate_structure:
	input: 
		"{path}/{{experiment}}_{{rRNA}}_{{method}}.ct".format(path = exp_path),
		"{path}/yeast_{{rRNA}}.ct".format(path = gt_path)
	output:
		"{path}/{{experiment}}_{{rRNA,(18S|25S)}}_{{method,(PROBer|StructureFold|Modseeker|icSHAPE|baseline)}}.eval".format(path = exp_path)
	shell:
		"{scorer} {input} {output}"

rule generate_structure_prediction_result:
	input:
		expand("{path}/yeast_{rRNA}_baseline.eval", path = exp_path, rRNA = ["18S", "25S"]),
		expand("{path}/mod_seq_{rRNA}_{method}.eval", path = exp_path, rRNA = ["18S", "25S"], method = ["PROBer", "Modseeker", "icSHAPE"]),
		expand("{path}/ChemModSeq_{rRNA}_{method}.eval", path = exp_path, rRNA = ["18S", "25S"], method = ["PROBer", "StructureFold", "Modseeker", "icSHAPE"])
	output:
		"{path}/yeast_structure_prediction_table.txt".format(path = result_path)
	shell:
		"{script_path}/generate_structure_prediction_table {output} {input}"

## Calculate AUC values of ROC curves for a variety of data sets

### structure-seq data
rule calc_structure_seq_ROC_AUC:
	input:
		expand("{path}/arabidopsis_{name}.{suffix}", path = gt_path, name = ["18S", "25S"], suffix = ["structure", "isac"]),
		expand("{path}/structure_seq_{method_suffix}", path = exp_path,
			method_suffix = ["sorted_PROBer.beta", "StructureFold.scores", "Modseeker.scores", "icSHAPE.scores"])
	output:
		"{path}/structure_seq_roc_auc.txt".format(path = exp_path)
	shell:
		"{script_path}/calcROC {gt_path} 36 {exp_path}/structure_seq {output}"

### Mod-seq data
rule calc_mod_seq_ROC_AUC:
	input:
		expand("{path}/yeast_{name}.{suffix}", path = gt_path, name = ["18S", "25S"], suffix = ["structure", "isac"]),
		expand("{path}/mod_seq_{method_suffix}", path = exp_path,
			method_suffix = ["PROBer.beta", "Modseeker.scores", "icSHAPE.scores"])
	output:
		"{path}/mod_seq_roc_auc.txt".format(path = exp_path)
	shell:
		"{script_path}/calcROC {gt_path} 49 {exp_path}/mod_seq {output}"

### icSHAPE data
rule calc_icSHAPE_ROC_AUC:
	input:
		expand("{path}/mouse_{name}.{suffix}", path = gt_path, name = ["18S", "12S_Mt"], suffix = ["structure", "isac"]),
		expand("{path}/icSHAPE_{{condition}}_{method_suffix}", path = exp_path,
			method_suffix = ["PROBer.beta", "StructureFold.scores", "Modseeker.scores", "icSHAPE.scores"])
	output:
		"{path}/icSHAPE_{{condition,(invitro|invivo)}}_roc_auc.txt".format(path = exp_path)
	shell:
		"{script_path}/calcROC {gt_path} 86 {exp_path}/icSHAPE_{wildcards.condition} {output}"

rule generate_roc_auc_table:
	input:
		expand("{path}/{name}_roc_auc.txt", path = exp_path, name = ["structure_seq", "mod_seq", "icSHAPE_invitro", "icSHAPE_invivo"])
	output:
		"{path}/structure_probing_roc_auc_table.txt".format(path = result_path)
	shell:
		"{script_path}/generate_structure_probing_roc_auc_table {input} {output}"

## SHAPES data for priming bias

rule align_reads_SHAPES:
	input:
		ecoli_rRNA,
		expand("{path}/{{sample}}_trimmed_{mate}.fq", path = VintherLab, mate = ["1", "2"]),
		Bowtie2, Samtools
	output: 
		expand("{path}/SHAPES_{{sample,(DMSO_no-sel|NPIA_no-sel|NPIA_sel)}}.bam", path = exp_path)
	threads: 10
	log: expand("{path}/{{sample}}.log", path = exp_path)
	shell:
		"{Bowtie2} -p {threads} -N 1 -L 15 --norc -X 700 --no-mixed --no-discordant -x {input[0]} -1 {input[1]} -2 {input[2]} 2> {log} | {Samtools} view -b -o {output} -"

def get_bam_as_input_SHAPES(wildcards):
	name = ""
	if wildcards.sample == "minus":
		name = "DMSO_no-sel"
	elif wildcards.sample == "plus":
		name = "NPIA_no-sel"
	else:
		name = wildcards.sample

	return expand("{path}/SHAPES_{name}.bam", path = exp_path, name = name)

rule trim_terminals_SHAPES:
	input:
		ecoli_rRNA + ".fa",
		get_bam_as_input_SHAPES
	output: 
		expand("{path}/SHAPES_trimmed_{{sample,(minus|plus|NPIA_sel)}}_all.bam", path = exp_path)
	log: expand("{path}/SHAPES_trimmed_{{sample}}_all.log", path = exp_path)
	shell:
		"{script_path}/trimMismatch_SHAPES {input} {output} > {log}"		

rule collect_data_for_RNAprobR_SHAPES:
	input:
		expand("{path}/SHAPES_trimmed_{{sample}}_all.bam", path = exp_path)
	output:
		expand("{path}/SHAPES_trimmed_{{sample,(minus|plus|NPIA_sel)}}.{suffix}", path = exp_path, suffix = ["counts", "bias"])
	shell:
		"{script_path}/collect_data_for_RNAprobR {input} exp/SHAPES_trimmed_{wildcards.sample}"

rule plot_bias_SHAPES:
	input: 
		expand("{path}/SHAPES_trimmed_{sample}.bias", path = exp_path, sample = ["minus", "plus", "NPIA_sel"])
	output:
		expand("{path}/SHAPES_bias.pdf", path = result_path)
	shell:
		"scripts/plotBias {input} {output}"

rule plot_ROC_SHAPES:
	input:
		expand("{path}/ecoli_16S.{suffix}", path = gt_path, suffix = ["structure", "sasa"]),
		expand("{path}/SHAPES_trimmed_{sample}.counts", path = exp_path, sample = ["minus", "plus", "NPIA_sel"]),
		expand("{path}/SHAPES_trimmed{extra}_PROBer.beta", path = exp_path, extra = ["", "_NPIA_sel"])
	output:
		expand("{path}/SHAPES_{sel}_{type}.pdf", path = result_path, sel = ["sel", "no_sel"], type = ["pr", "roc"])
	shell:
		"scripts/plot_PR_ROC_SHAPES {input} {result_path}/SHAPES"


# Pseudo-seq experiments for Pseudouridine modification

rule generate_pseudoU_PR_ROC_plots:
	input:
		yeast_filt,
		expand("{path}/{name}.truth", path = gt_path, name = ["18S", "25S", "5S", "58S", "LSR1"]),
		expand("{path}/pseudo_seq_{method_suffix}", path = exp_path,
			method_suffix = ["PROBer.beta", "Pseudoseq.scores", "StructureFold.scores", "Modseeker.scores", "icSHAPE.scores"])
	output:
		expand("{path}/pseudoU_{type}.pdf", path = result_path, type = ["pr", "roc"])
	shell:
		"{script_path}/plot_PR_ROC_pseudoU {input[0]}.transcripts.fa {gt_path} {exp_path}/pseudo_seq {result_path}/pseudoU"

rule visualize_18S_for_pseudoU_experiment:
	input:
		"{path}/18S.truth".format(path = gt_path),
		"{path}/pseudo_seq_PROBer.beta".format(path = exp_path),
		expand("{path}/pseudo_seq_{method}.scores", path = exp_path, method = ["Pseudoseq", "StructureFold", "Modseeker", "icSHAPE"])
	output:
		"{path}/pseudoU_18S.pdf".format(path = result_path)
	shell:
		"{script_path}/plotPseudoUScore {input} 36 1,500,1000,1191,1500,1800 \"18S rRNA\" {output}"




# iCLIP

def get_iCLIP_data_as_input(wildcards):
	if wildcards.name.find("UleLab") >= 0:
		return UleLab + "/hnRNPC_HeLa_UleLab_rep1_reprm.fq"
	else:
		return YeoLab_iCLIP + "/SRR3147675_reprm.fq"

rule run_PROBer_iCLIP:
	input:
		human_ref,
		get_iCLIP_data_as_input,
		PROBer, Bowtie
	params: 
		sample_name = "{path}/{{name}}".format(path = exp_path)
	output:
		expand("{path}/{{name,(hnRNPC_HeLa_UleLab_rep1|RBFOX2_293T_YeoLab_iCLIP)}}.{suffix}", path = exp_path, suffix = ["site_info", "alignments.bam"])
	threads: 20
	shell:
		"{PROBer} iCLIP -p {threads} --bowtie --bowtie-path {bowtie_path} --index-name {input[0]} --keep-alignments {params.sample_name} --reads {input[1]}"

rule run_PROBer_naive_iCLIP:
	input:
		"{path}/{{name}}.alignments.bam".format(path = exp_path),
		PROBer
	params: 
		sample_name="{path}/{{name}}_naive".format(path = exp_path)
	output:
		"{path}/{{name,(hnRNPC_HeLa_UleLab_rep1|RBFOX2_293T_YeoLab_iCLIP)}}_naive.site_info".format(path = exp_path)
	shell:
		"{PROBer} iCLIP --naive {params.sample_name} --alignments {input[0]}"

rule sample_multireads_iCLIP:
	input: 
		expand("{path}/{{name}}.{suffix}", path = exp_path, suffix = ["alignments.bam", "site_info"]),
		PROBer_sampler
	params:
		sample_name="{path}/{{name}}".format(path = exp_path),
		stat_name ="{path}/{{name}}.stat/{{name}}".format(path = exp_path)
	output:
		"{path}/{{name,(hnRNPC_HeLa_UleLab_rep1|RBFOX2_293T_YeoLab_iCLIP)}}.sampled.bam".format(path = exp_path)
	shell:
		"{PROBer_sampler} {params.sample_name} {params.stat_name} {input[0]} --seed 0"


# eCLIP

def get_eCLIP_data_as_input(wildcards):
	if wildcards.protein == "RBFOX2":
		assert wildcards.cell_line == "293T"
		if wildcards.rep == "input":
			return expand("{path}/SRR3147600_reprm_{mate}.fq", path = YeoLab_eCLIP, mate = ["1", "2"])
		else:
			return expand("{path}/{run}_reprm_{mate}.fq", path = YeoLab_eCLIP, run = ["SRR3147598", "SRR3147599"], mate = ["1", "2"])
	else:
		return expand("{path}/{protein}_{cell_line}_YeoLab_{rep}_reprm_{mate}.fq", 
			path = YeoLab_eCLIP, protein = wildcards.protein, cell_line = wildcards.cell_line, 
			rep = wildcards.rep, mate = ["1", "2"])

def get_eCLIP_mate1(wildcards):
	if wildcards.protein == "RBFOX2":
		assert wildcards.cell_line == "293T"
		if wildcards.rep == "input":
			return "{path}/SRR3147600_reprm_1.fq".format(path = YeoLab_eCLIP)
		else:
			return ",".join(["{path}/{run}_reprm_1.fq".format(path = YeoLab_eCLIP, run = run) for run in ["SRR3147598", "SRR3147599"]])
	else:
		return "{path}/{protein}_{cell_line}_YeoLab_{rep}_reprm_1.fq".format(path = YeoLab_eCLIP,
			protein = wildcards.protein, cell_line = wildcards.cell_line, rep = wildcards.rep)

def get_eCLIP_mate2(wildcards):
	if wildcards.protein == "RBFOX2":
		assert wildcards.cell_line == "293T"
		if wildcards.rep == "input":
			return "{path}/SRR3147600_reprm_2.fq".format(path = YeoLab_eCLIP)
		else:
			return ",".join(["{path}/{run}_reprm_2.fq".format(path = YeoLab_eCLIP, run = run) for run in ["SRR3147598", "SRR3147599"]])
	else:
		return "{path}/{protein}_{cell_line}_YeoLab_{rep}_reprm_2.fq".format(path = YeoLab_eCLIP,
			protein = wildcards.protein, cell_line = wildcards.cell_line, rep = wildcards.rep)		

def get_eCLIP_extra(wildcards):
	if wildcards.protein == "RBFOX2" and wildcards.rep == "rep1":
		return "--time --memory"
	return ""

rule run_PROBer_eCLIP:
	input:
		human_ref,
		get_eCLIP_data_as_input,
		PROBer, Bowtie2
	params: 
		sample_name = "{path}/{{protein}}_{{cell_line}}_YeoLab_{{rep}}".format(path = exp_path),
		mate1 = get_eCLIP_mate1,
		mate2 = get_eCLIP_mate2,
		extra = get_eCLIP_extra
	output:
		expand("{path}/{{protein,[A-Za-z0-9]+}}_{{cell_line,[A-Z0-9]+}}_YeoLab_{{rep,(rep1|input)}}.{suffix}", 
			path = exp_path, suffix = ["site_info", "alignments.bam"])
	threads: 20
	shell:
		"{PROBer} iCLIP --eCLIP --paired-end -p {threads} --bowtie2 --bowtie2-path {bowtie2_path} --index-name {input[0]} --keep-alignments {params.extra} {params.sample_name} --reads {params.mate1} {params.mate2}"

rule run_PROBer_naive_eCLIP:
	input:
		"{path}/{{protein}}_{{cell_line}}_YeoLab_{{rep}}.alignments.bam".format(path = exp_path),
		PROBer
	params: 
		sample_name="{path}/{{protein}}_{{cell_line}}_YeoLab_{{rep}}_naive".format(path = exp_path)
	output:
		"{path}/{{protein,[A-Za-z0-9]+}}_{{cell_line,[A-Z0-9]+}}_YeoLab_{{rep,(rep1|input)}}_naive.site_info".format(path = exp_path)
	shell:
		"{PROBer} iCLIP --eCLIP --paired-end --naive {params.sample_name} --alignments {input[0]}"

rule sample_multireads_eCLIP:
	input: 
		expand("{path}/{{protein}}_{{cell_line}}_YeoLab_{{rep}}.{suffix}", path = exp_path, suffix = ["alignments.bam", "site_info"]),
		PROBer_sampler
	params:
		sample_name="{path}/{{protein}}_{{cell_line}}_YeoLab_{{rep}}".format(path = exp_path),
		stat_name ="{path}/{{protein}}_{{cell_line}}_YeoLab_{{rep}}.stat/{{protein}}_{{cell_line}}_YeoLab_{{rep}}".format(path = exp_path)
	output:
		"{path}/{{protein,[A-Za-z0-9]+}}_{{cell_line,[A-Z0-9]+}}_YeoLab_{{rep,(rep1|input)}}.sampled.bam".format(path = exp_path)
	shell:
		"{PROBer_sampler} {params.sample_name} {params.stat_name} {input[0]} --eCLIP --seed 0"



rule extract_unique_CLIP:
	input:
		"{path}/clipper_header.txt".format(path = exp_path), 
		"{path}/{{protein}}_{{cell_line}}_{{lab}}_{{rep}}.alignments.bam".format(path = exp_path)
	output: "{path}/{{protein,[A-Za-z0-9]+}}_{{cell_line,[A-Za-z0-9]+}}_{{lab,(UleLab|YeoLab)}}_{{rep,(rep1|input|iCLIP)}}_unique.bam".format(path = exp_path)
	shell:
		"{script_path}/extract_CLIP_reads_from_bam {input[0]} {input[1]} {output}"

rule extract_all_CLIP:
	input:
		"{path}/clipper_header.txt".format(path = exp_path), 
		"{path}/{{protein}}_{{cell_line}}_{{lab}}_{{rep}}.sampled.bam".format(path = exp_path)
	output: "{path}/{{protein,[A-Za-z0-9]+}}_{{cell_line,[A-Za-z0-9]+}}_{{lab,(UleLab|YeoLab)}}_{{rep,(rep1|input|iCLIP)}}_all.bam".format(path = exp_path)
	shell:
		"{script_path}/extract_CLIP_reads_from_bam {input[0]} {input[1]} {output}"

rule samtools_sort_CLIP:
	input: "{path}/{{name}}_{{ending}}.bam".format(path = exp_path), Samtools
	output: "{path}/{{name,\w+}}_{{ending,(unique|all)}}.sorted.bam".format(path = exp_path)
	threads: 10
	shell:
		"{Samtools} sort -@ {threads} -o {output} {input[0]}"

rule samtools_index_CLIP:
	input: "{path}/{{name}}.sorted.bam".format(path = exp_path), Samtools
	output: "{path}/{{name,\w+}}.sorted.bam.bai".format(path = exp_path)
	shell:
		"{Samtools} index {input[0]}"

rule run_CLIPper_CLIP:
	input: expand("{path}/{{name}}.sorted.bam{extra}", path = exp_path, extra = ["", ".bai"])
	output: "{path}/{{name,\w+}}.sorted.peaks.bed".format(path = exp_path)
	threads: 20
	shell:
		"clipper -b {input[0]} -s GRCh38 -o {output} --bonferroni --superlocal --threshold-method binomial --processors={threads} --save-pickle"



rule merge_peaks_iCLIP:
	input: 
		"{path}/GRCh38.txt".format(path = exp_path),
		"{path}/{{name}}_{{ending}}.sorted.peaks.bed".format(path = exp_path)
	output:
		"{path}/{{name,(hnRNPC_HeLa_UleLab_rep1|RBFOX2_293T_YeoLab_iCLIP)}}_{{ending,(unique|all)}}.merged.peaks.bed".format(path = exp_path)
	shell:
		"{script_path}/mergeCLIPPERpeaks {input} {output}"

import os

rule normalize_peaks_eCLIP:
	input:
		expand("{path}/{{protein}}_{{cell_line}}_YeoLab_rep1_{{ending}}.sorted.{suffix}", path = exp_path, suffix = ["peaks.bed", "bam", "bam.bai"]),
		expand("{path}/{{protein}}_{{cell_line}}_YeoLab_input_{{ending}}.sorted.bam{extra}", path = exp_path, extra = ["", ".bai"]),
		"{path}/GRCh38.txt".format(path = exp_path)
	params: sample = "{path}/{{protein}}_{{cell_line}}_YeoLab_rep1_{{ending}}".format(path = exp_path)
	output: 
		"{path}/{{protein,[A-Za-z0-9]+}}_{{cell_line,[A-Z0-9]+}}_YeoLab_rep1_{{ending,(unique|all)}}.norm.peaks.bed".format(path = exp_path)
	run:
		shell("rm -rf {params.sample} {params.sample}.manifest {params.sample}.manifest.mapped_read_num")	
		with open(params.sample + ".manifest", "w") as fout:
			fout.write("uID\tRBP\tCell_line\tCLIP_rep1\tINPUT\n")
			fout.write("001\t{protein}\t{cell_line}\t{working_directory}/{exp}\t{working_directory}/{input}\n".format(protein = wildcards.protein, cell_line = wildcards.cell_line, working_directory = os.getcwd(), exp = input[1], input = input[3]))
		shell("mkdir -p {params.sample}")
		shell("perl {script_path}/YeoLab_perl_scripts/Peak_input_normalization_wrapper.pl {params.sample}.manifest {params.sample}")
		shell("{script_path}/fdrCompressedPeaks {input[5]} {params.sample}/001_01.basedon_001_01.peaks.l2inputnormnew.bed.compressed.bed {output}")




protein2motif = {"RBFOX2" : "TGCATG", "TARDBP" : "GAATG", "TRA2A" : "GAAGAA", "PUM2" : "\"TGTA[ACGTN]ATA\"", "hnRNPC" : "TTTTT"}

def get_motif(wildcards):
	return protein2motif[wildcards.protein]

def get_input_bed_file_CLIP(wildcards):
	return "{path}/{protein}_{content}_{ending}.{name}.peaks.bed".format(path = exp_path,
			protein = wildcards.protein, content = wildcards.content, ending = wildcards.ending, 
			name = "norm" if wildcards.type == "eCLIP" else "merged") 

rule count_rate_for_peaks_CLIP:
	input:
		human_genome,
		get_input_bed_file_CLIP,
		script_path + "/countMotifRate"
	params: motif = get_motif
	output: 
		"{path}/{{protein,[A-Za-z0-9]+}}_{{content}}_{{ending,(unique|all)}}.{{type,(iCLIP|eCLIP)}}.mhr".format(path = exp_path)
	shell:
		"{script_path}/countMotifRate {input[0]} {params.motif} 100 {input[1]} > {output}"

rule extract_context_for_sites_CLIP:
	input:
		human_genome,
		"{path}/{{protein}}_{{content}}.site_info".format(path = exp_path),
		script_path + "/detectMotif"
	params: motif = get_motif
	output:
		"{path}/{{protein,[A-Za-z0-9]+}}_{{content}}.100.motif".format(path = exp_path)
	shell:
		"{script_path}/detectMotif {input[0]} {params.motif} 100 {input[1]} {output}"

rule calculate_weighted_rate_for_sites_CLIP:
	input: 
		"{path}/{{protein}}_{{cell_line}}_{{lab}}_{{rep}}.100.motif".format(path = exp_path),
		"{path}/{{protein}}_{{cell_line}}_{{lab}}_{{rep}}{{extra}}.site_info".format(path = exp_path),
		script_path + "/calcWeightedMotifRate"
	output:
		"{path}/{{protein,[A-Za-z0-9]+}}_{{cell_line,[A-Za-z0-9]+}}_{{lab,(UleLab|YeoLab)}}_{{rep,(rep1|iCLIP)}}{{extra,(|_naive)}}.{{w,\d+}}.mhwr".format(path = exp_path)
	shell:
		"{script_path}/calcWeightedMotifRate {wildcards.w} {input[0]} {input[1]} > {output}"



# CLIP outputs

rule generate_iCLIP_site_result_table:
	input:
		expand("{path}/RBFOX2_293T_YeoLab_iCLIP{extra}.{w}.mhwr", path = exp_path, extra = ["", "_naive"], w = ["10", "20", "30", "40", "50", "100"]),
		expand("{path}/hnRNPC_HeLa_UleLab_rep1{extra}.{w}.mhwr", path = exp_path, extra = ["", "_naive"], w = ["10", "20", "30", "40", "50", "100"])
	output:
		"{path}/iCLIP_site_result_table.txt".format(path = result_path)
	shell:
		"{script_path}/generate_site_mhwr_table iCLIP {output} 10,20,30,40,50,100 {input}"

rule generate_eCLIP_site_result_table_eCLIP:
	input:
		expand("{path}/RBFOX2_293T_YeoLab_rep1{extra}.{w}.mhwr", path = exp_path, extra = ["", "_naive"], w = ["10", "20", "30", "40", "50", "100"]),
		expand("{path}/{protein}_K562_YeoLab_rep1{extra}.{w}.mhwr", path = exp_path, protein = ["TARDBP", "TRA2A", "PUM2"], extra = ["", "_naive"], w = ["10", "20", "30", "40", "50", "100"])
	output:
		"{path}/eCLIP_site_result_table.txt".format(path = result_path)
	shell:
		"{script_path}/generate_site_mhwr_table eCLIP {output} 10,20,30,40,50,100 {input}"		

rule generate_iCLIP_peak_result_table:
	input:
		expand("{path}/RBFOX2_293T_YeoLab_iCLIP_{ending}.iCLIP.mhr", path = exp_path, ending = ["unique", "all"]),
		expand("{path}/hnRNPC_HeLa_UleLab_rep1_{ending}.iCLIP.mhr", path = exp_path, ending = ["unique", "all"])
	output:
		"{path}/iCLIP_peak_result_table.txt".format(path = result_path)
	shell:
		"{script_path}/generate_peak_mhr_table iCLIP {output} {input}"

rule generate_eCLIP_peak_result_table:
	input:
		expand("{path}/RBFOX2_293T_YeoLab_rep1_{ending}.eCLIP.mhr", path = exp_path, ending = ["unique", "all"]),
		expand("{path}/{protein}_K562_YeoLab_rep1_{ending}.eCLIP.mhr", path = exp_path, protein = ["TARDBP", "TRA2A", "PUM2"], ending = ["unique", "all"])
	output:
		"{path}/eCLIP_peak_result_table.txt".format(path = result_path)
	shell:
		"{script_path}/generate_peak_mhr_table eCLIP {output} {input}"
